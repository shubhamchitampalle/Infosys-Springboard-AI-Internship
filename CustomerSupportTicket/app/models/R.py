# -*- coding: utf-8 -*-
"""Response Automation using genai.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cI5Rwkybid5dwK2L-sOzWaQQ4aJj5v10
"""

# !pip install "gspread==6.1.3"

# !pip install "pinecone"
import re
import json
PINECONE_KEY="pcsk_7QAmeq_7L4N6t6t62BqqoVPk2WZp9sFTAoKNpNXi3V2yVkJWk3uR3cXN3HfzZx3hWwaba2"

import gspread
from google.oauth2.service_account import Credentials

scopes = [
    'https://www.googleapis.com/auth/spreadsheets',
    'https://www.googleapis.com/auth/drive'
]

credentials = Credentials.from_service_account_file(
    '/content/my-project-response-29749ee50e47.json',
    scopes=scopes
)

gc = gspread.authorize(credentials)
sh = gc.open_by_key("1tyxACc95GD88T2Me_xhktYbc14P6-BBZkOWlT7MUaeU")

# prompt: read sheet into pandas frame
import pandas as pd
# Assuming 'sh' is your opened Google Sheet from the previous code
worksheet = sh.sheet1  # Or specify the correct sheet name or index

# Get all values from the worksheet
data = worksheet.get_all_values()

# Convert to DataFrame
df_sheets = pd.DataFrame(data[1:], columns=data[0])  # First row is header
df_sheets.head()

df_sheets.shape

from pinecone import Pinecone
from pinecone import ServerlessSpec


pc = Pinecone(api_key=PINECONE_KEY)

# Instead of creating a new index, try connecting to the existing "example-index" or
# choose a different name if you intend to create a new one.
# For example, to connect to the existing "example-index":
index = pc.Index("support-tickets")

# If you want to create a new index with a different name, change "example-index" to a unique name
# pc.create_index(
#   name="support-tickets",  # Changed to a new name
#   dimension=1536,
#   metric="cosine",
#   spec=ServerlessSpec(
#     cloud="aws",
#     region="us-east-1"
#   )
# )
# index = pc.Index("support-tickets") # Connect to the newly created index

# import google.generativeai as genai

genai.configure(api_key="AIzaSyCfMhjWIAnVNdJwamWWhP0BTTi-Y8w0H2k")
model = genai.GenerativeModel("gemini-pro")



def extract_issue_product(title, body):
    """
    Extract product name and issue sentence using Gemini API.
    """
    prompt = f"""Extract the product name and issue from the following:
    Title: {title}
    Body: {body}
    Provide output in JSON format with keys 'product_name' and 'issue_sentence'."""

    response = model.generate_content(prompt)
    extracted_data = response.text.strip()

    # Remove code block markers like ```JSON and ```
    cleaned_data = re.sub(r"```[a-zA-Z]*\n|\n```", "", extracted_data).strip()

    try:
        extracted_json = json.loads(cleaned_data)
        return extracted_json.get('product_name', 'Unknown'), extracted_json.get('issue_sentence', 'Unknown')
    except json.JSONDecodeError as e:
        raise ValueError(f"Error parsing JSON response: {e}\nResponse: {cleaned_data}")

import google.generativeai as genai

def get_top_similar_issues(issue_sentence, top_k=3):
    """
    Find top similar issues using Pinecone.
    """
    # Generate embeddings using Gemini's embedding API
    embedding_response = genai.embed_content(
        model="models/embedding-001",  # Correct model for embedding
        content=issue_sentence,
        task_type="retrieval_document"
    )
    embedding = embedding_response['embedding']

    # Search Pinecone index
    result = index.query(vector=embedding, top_k=top_k, include_metadata=True)

    return result['matches']



def generate_personalized_response(product_name, issue_sentence, similar_issues):
    """
    Generate personalized response using Gemini API.
    """
    # Ensure we have at least 3 similar issues; fill missing ones with placeholders
    while len(similar_issues) < 3:
        similar_issues.append({'metadata': {'issue': 'No similar issue found', 'response': 'No response available'}})

    prompt = f"""
    Product: {product_name}
    User Issue: {issue_sentence}

    Here are similar issues and their responses:
    1. {similar_issues[0]['metadata']['issue']} - {similar_issues[0]['metadata']['response']}
    2. {similar_issues[1]['metadata']['issue']} - {similar_issues[1]['metadata']['response']}
    3. {similar_issues[2]['metadata']['issue']} - {similar_issues[2]['metadata']['response']}

    Generate a subject and a body to respond helpfully to the user.
    Provide output in JSON format with keys 'subject' and 'body'.
    """
    response = model.generate_content(prompt)

    # Clean up the response string by removing the code block markers (```)
    cleaned_data = re.sub(r"```[a-zA-Z]*\n|\n```", "", response.text.strip()).strip()

    try:
        # Parse the cleaned data as JSON
        extracted_json = json.loads(cleaned_data)
        return extracted_json.get('subject', 'No subject'), extracted_json.get('body', 'No body')
    except json.JSONDecodeError as e:
        raise ValueError(f"Error parsing JSON response: {e}\nResponse: {cleaned_data}")

def automate_response(title, body):
    """
    Full automation workflow for issue resolution.
    """
    # Step 1: Extract product name and issue
    product_name, issue_sentence = extract_issue_product(title, body)

    # Step 2: Find similar issues
    similar_issues = get_top_similar_issues(issue_sentence)

    # Step 3: Generate a personalized response
    subject, response_body = generate_personalized_response(
        product_name, issue_sentence, similar_issues
    )

    return subject, response_body

# title = "App crashes on startup"
# body = "Whenever I open the app, it just crashes without any error message. Please help!"

# subject, response_body = automate_response(title, body)
# print("Generated Response:")
# print("Subject:", subject)
# print("Body:", response_body)
# # Combine subject and body into a dictionary
# response_dict = {"subject": subject, "body": response_body}
# # Display the dictionary
# response_dict

title = "Cisco router Issue"
body = "Facing Network Connectivity Issues with cisco Router"
subject, response_body = automate_response(title, body)
print("Generated Response:")
print("Subject:", subject)
print("Body:", response_body)
response_dict = {"subject": subject, "body": response_body}
print(response_dict)